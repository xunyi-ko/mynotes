1.TDD三定律
    1.在编写不能通过的单元测试前，不可编写生产代码
    2.只可编写刚好无法通过的单元测试
    3.只可编写刚好足以通过当前失败测试的生产代码
    
    这样写程序，我们每天就会写数十个测试，每个月写数百个测试。测试会覆盖所有生产代码，测试代码量足以匹敌生产代码量，导致令人生畏的管理问题

2.保持测试整洁
    有的人认为，测试代码的维护不应遵循生产代码的质量标准，他们彼此默许在单元测试中破坏规矩。只要能工作就行
    然而，他们没意识到：脏测试等于没测试。原因在于，测试必须随生产代码的演进而修改。测试越脏，就越难修改，需要花更多的时间来塞进新的测试，而不是编写新的生产代码
    随着版本递进，测试的代价也在上升。于是他们抛弃了测试。但是失去了测试代码组，他们就失去了确保对代码的改动能如愿工作的能力。
    
    测试确实让他们失望了，不过原因是他们把测试做的乱七八糟
    故事的寓意很简单：测试代码和生产代码一样重要。它需要被思考、被设计和被照料。它应该像生产代码一般保持整洁
    
    测试带来一切好处
    如果测试不能保持整洁，你就会失去它们。如果没有了测试，你就会失去保证生产代码可扩展的一切要素。
    正是单元测试让你的代码可扩展、可维护、可服用。原因很简单，有了测试，你就不用担心对代码的修改会造成不可预知的问题。
    没有测试，每次修改都可能带来缺陷。无论架构多有扩展性，无论设计划分得多好，没有测试，你就很难做改动。

3.整洁的测试
    整洁的测试最重要的就是可读性。在单元测试中，可读性比在生产代码中还重要。
    如何做到可读性？和其他代码一样：明确，简洁，还有足够的表达力。
    
4.每个测试一个断言
    有个流派认为，JUnit中的每个测试函数都应该有且只有一个断言语句。这条规则看似过于苛求，不过却有它的好处。
    但是也不必苛求，更好的说法是，单个测试中的断言数量应该最小化
    
    每个测试一个概念
    更好一些的规则或许是每个测试函数中只测试一个概念，

5.F.I.R.S.T.
    整洁的测试还遵循以下5条规则
    快速(fast)    测试应该够快。因为测试需要频繁的运行，否则无法尽早发现问题，也无法轻易修正
    独立(independent) 测试应该相互独立。某个测试不应为下一个测试设定条件。每个测试都应该可以单独运行，及以任何顺序运行
    可重复(repeatable) 测试应当可在任何环境中重复通过。
    自足验证(self-validating)   测试应该有布尔值输出，无论是通过或失败。
        不应该查看日志文件来确认测试是否通过。不应该手工对比两个不同文本文件来确认测试是否通过。
        如果不能自己验证是否正确的话，判断就会变得依赖主管，而运行测试也需要更长的手工操作时间。
    及时(timely)  测试应及时编写。单元测试应该恰好在使其通过的生产代码前编写。
        如果在之后编写测试，你会发现难以测试。你可能会认为某些代码本身难以测试，而不去设计可测试的代码
        
6.小结
    对于项目的健康度，测试和生产代码同等重要。或许测试更为重要。因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。
