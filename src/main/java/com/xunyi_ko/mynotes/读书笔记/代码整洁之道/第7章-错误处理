错误处理是编程时必须要做的事之一，当错误发生时，程序员有责任确保代码照常工作
错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法

1.使用异常而非返回码
    在很久以前，许多语言不支持异常，这些语言处理和汇报错误的手段有限。要么设置一个错误标识，要么返回错误码
    这种方式的问题在于，它们搞乱了代码。调用者必须在调用之后即刻检查错误。然而这个步骤很容易被遗忘
    最好在遇到错误时抛出一个异常。
    
2.先写try-catch-finally
    异常的好处之一是，它们在程序中定义了一个范围，执行try-catch-finally语句中try部分的代码时，表明了代码随时可能取消执行，并在catch语句中接续
    
3.使用运行时异常
    Java的第一个版本中引入编译期异常，如果没有抛出，则无法运行。但是它并不是必须的。我们得确定编译期异常是否值得
    
    编译期异常的代价就是违反开闭原则。乳沟在方法中抛出可控异常，那么久必须在每个方法之间声明该异常
    这意味着较低层级的修改，都将波及到较高层级。具体情况具体分析吧
    
4.给出异常发生的环境说明
    抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。
    在Java中，我们可以在任何异常里得到堆栈的踪迹，但是堆栈的踪迹无法告诉你该失败操作的原因
    写上足够清晰的内容，以便查找异常
    
5.依调用者需要定义异常类
    对于错误分类有很多方式，可以依其来源分类，类型分类等等。不过最重要的，是考虑清楚它们如何被捕获
    
6.定义常规流程
    如果遵循前文的建议，在业务逻辑和错误处理代码之间就会有良好的间隔，大量代码会变得整洁而简约。
    然而这么做却把错误检测推到程序的边缘地带。
    打包外部API以抛出自己的异常，在代码顶端定义了一个处理器来应付所有失败了的代码。
    大多数时候这么做很棒，不过有时可能不太愿意这么做
    
    有时异常会打断业务逻辑，这有时并不是什么好事。
    我们可以选择把错误处理放在较深层的地方，方法总是返回一个合适的对象而不可能报错
    这种方法叫做特例模式。你来处理特例，客户代码就不用应付异常行为了

7.别返回null值
    要讨论错误处理，就一定要提及那些容易引发错误的做法。第一项就是返回null值
    返回null值基本就是给自己增加工作量，也是给调用者添乱。只要有一处没有检查null值，程序就会失控
    如果得到的结果是一个null值，可以考虑返回一个空的对象，或者空集合等，尽量避免NullPointerException
    
8.别传递null值
    在方法中返回null值是糟糕的做法，那么传递null值就更糟糕了。除非API要求你传递null值，否则就要尽可能避免传递null值

小结
    整洁代码是可读的，但也要强固，这并不矛盾
    如果将错误处理隔离出来，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性
