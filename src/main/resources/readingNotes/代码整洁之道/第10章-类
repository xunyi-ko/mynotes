本书到目前为止一直在讨论如何编写良好的代码行和代码块。我们深入研究了函数的恰当构成，以及函数之间如何互相关联。
不过，尽管讨论了这么多关于代码语句及由代码语句构成的函数的表达力，除非我们将注意力放到代码组织的更高层面，就始终不能得到整洁的代码

1.类的组织
    遵循标准的java约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现，然后是私有静态变量，以及私有实体变量。很少会有公共变量
    
    封装
        我们喜欢保持变量和工具函数的私有性，但并不执着于此。有时我们也需要用到protected变量或工具函数，好让测试可以访问到
        有时为了可以测试，会将函数或变量设为protected或者default。然而首先会想办法用private，放松封装总是下策

2.类应该短小
    关于类，最重要的，就是短小。在设计类是，首条规则就是要更短小，那么多大合适呢？
    
    单一职责原则(SRP)认为，类或模块应该有且只有一条加以修改的理由。该原则即给出了职责的定义，又是关于类的长度的指导方针。类只应有一个职责(一个修改的理由)
    鉴别职责(修改的理由)能帮助我们在代码中认识到并创建出更好的抽象
    
    SRP是OO设计中最为重要的概念之一，也是较为容易理解和遵循的概念之一。奇怪的是，SRP往往也是最容易被破坏的类设计原则。为什么呢
    问题是太多人在程序能工作时就意味万事大吉了，没能把思维转向有关代码组织和整洁的部分，直接去做下一个事，而不是回头把臃肿的类划分为只有单一职责的去耦式单元
    每个达到一定规模的系统都会包括大量逻辑和复杂性，管理这种复杂性的首要目标就是加以组织，以便开发人员知道到哪能找到东西
    再次强调：系统应该由许多短小的类，而不是少量巨大的类组成。每个小类封装一个职责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为
    
    内聚
        类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越依赖类(内聚)
        一般来说，创建这种极大化内聚类既不可取，也不可能。另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量相互依赖、互相结合成一个逻辑整体
        保持函数和参数列表短小的策略，有时会导致一组子集方法所用的实体变量数量增加。出现这种情况时，往往意味着至少一个类要从大类中分出来。
        我们应该尝试将这些变量或方法分拆到两个或多个类中，让新的类更为内聚

3.为了修改而组织
    对于多数系统，修改将一直持续。每处修改都让我们冒着系统其它部分不能如期望般工作的风险。在整洁的系统中，我们对类加以组织，以降低修改的风险
    
    
